### 关于索引

**为什么要使用索引：** 避免全表扫描，提升查找效率

**什么样的信息能成为索引：** 主键、唯一键以及普通键等

**索引的数据结构：** 二叉查找树、B树、 **B+树** 、**Hash结构**

**（IO次数与要查询的值在树的第几层有关）**

- #### B树

1. 根节点至少包括两个孩子
2. 树中每个节点最多含有m个孩子(m>=2, m为多少即为几阶树)
3. 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子(ceil函数功能是取上整数, ceil(2.2)=3)
4. 所有叶子节点都位于同一层

- #### B+树 (数据库存储引擎主要采取的方式)

**B+树是B树的变体，其定义基本与B树相同，除了：**


1. 非叶子节点的子树指针P与关键字K个数相同
2. 非叶子节点的子树指针P[i]，指向关键字值(K[i], K[i+1])的子树
3. 非叶子节点仅用来索引，数据都保存在叶子节点中
4. 所有叶子节点均有一个链指针指向下一个叶子节点 (左叶子 - 右叶子)（支持范围统计）

**B+树更适合用来做存储索引：**

1. B+树的磁盘读写代价更低
2. B+树的查询效率更加稳定（即每个数据的查询效率基本相同O(lgn)）
3. B+树更有利于对数据库的扫描（即做范围查询时有更高的性能）

- #### Hash索引

**（理论上效率高于B+）**

**缺点：**

1. 仅仅能满足 "=", "IN", 不能使用范围查询
2. 数据库使用哈希索引到的值(V)并不是和键(K)一样有序的，还要重新进行排序运算（不能避免数据排序操作）
3. 不能利用联合索引的部分索引键查询
4. 不能避免表扫描
5. 遇到大量Hash值相等的情况后性能不一定就会比B+树索引高


- #### 密集索引和稀疏索引

**区别：**

1. 密集索引文件中的每个搜索码值都对应一个索引值
2. 稀疏索引文件只为索引码的某些值建立索引项

**针对MySQL中的InnoDB存储引擎** （MySQL不显式支持Hash，都是基于B+树）

1. 若一个主键被定义，该主键则作为密集索引（主键索引）
2. 若没有主键定义，该表的第一个唯一非空键则作为密集索引（辅助键索引）
3. 若不满足以上条件，InnoDB内部会生成一个隐藏主键(密集索引)（也是一种特殊的主键索引）
4. **非主键索引存储相关键位和其对应的主键值，故包含两次查找（先使用非主键索引查找主键，再通过主键索引查找内容）**
5. 索引和数据存储在同一个文件中

**针对MySQL中的MyISAM存储引擎**

1. 使用稀疏索引
2. 无论是主键索引还是辅助键索引都只需查找一次，但查找到对应位置后还需继续检索对应的值
3. 索引和数据分开存储

- #### 如何定位并优化慢查询SQL

**（具体场景具体分析，只提出大概思路）**

1. 根据慢日志定位慢查询SQL
2. 使用explain等工具分析SQL
3. 修改SQL或者尽量让SQL走索引

- #### 联合索引的最左匹配原则

**联合索引：** 多列组成的索引


1. 最左前缀匹配原则，MySQL会一直向右匹配知道遇到范围查询(>, <, between, like)就停止匹配，比如

`a=3 and b=4 and c>5 and d=6`  如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整

2. = 和 in 可以乱序，比如`a=1 and b =2 and c=3` 建立索引可以随意顺序，MySQL的查询优化器回优化成索引可以识别的形式
3. 如果跳过联合索引的第一个键来查询，如`b = 1 and c = 3` ，索引为(a,b,c)，则b,c 都不会用到这个索引

- #### 索引是建立的越多越好吗

1. 数据量小的表不需要建立索引，建立会增加额外的索引开销
2. 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
3. 更多的索引也意味着需要更多的空间

---

### 关于锁

**read锁：共享锁**	允许多个读锁并存但会堵塞写锁   

**write锁：排它锁**	只允许一个写锁存在且读锁也会堵塞

- #### MyISAM与InnoDB关于锁方面的区别

1. MyISAM默认用的是表级锁，不支持行级锁
2. InnoDB默认用的是行级锁，也支持表级锁。（支持事务，但同时也带来了更大的开销）

**MyISAM适合的场景**

1. 频繁执行全表count语句
2. 对数据进行增删改查的频率不高，查询非常频繁
3. 没有事务

**InnoDB适合的场景**

1. 数据增删改查都相当频繁
2. 可靠性要求比较高，要求支持事务


- #### 数据库锁的分类

**按锁的粒度划分：** 表级锁、行级锁、页级锁

**按锁的级别划分：** 共享锁、排它锁

**按加锁方式划分：** 自动锁、显式锁(即手动加锁)

**按操作划分：** DML锁(如对数据的增删改查)、DDL锁(如对表结构的变更)

**按使用方式划分：** 乐观锁(数据提交时才检测冲突，不使用数据库提供的锁机制而是手动使用：版本号、时间戳)、悲观锁(即全程用排它锁锁定：先取锁，后访问。更安全但是开销更大，死锁概率大)

- #### 数据库事务

**四大特性ACID：** 原子性(Atomic)、一致性(Consistency)、**隔离性**(Isolation)、持久性(Durability)

**事务并发访问引起的问题以及如何避免**

1. 更新丢失——MySQL所有事务隔离级别在数据库层面上均可避免
2. **脏读** (读到了未提交的事务操作后的数据)——READ-COMMITTED事务隔离级别(Oracle默认的级别)以上可避免
3. 不可重复读(并发事务下，同一事务连续读取同一行数据时会随其他事务的提交而改变)——REPEATABLE-READ事务隔离级别(InnoDB默认的级别)以上可以避免
4. **幻读** (ex:事务A执行读操作时发现n条数据，事务B在事务A影响区间内插入了一条记录并提交，然后事务A执行更新n条数据操作时会比事务A预想下多执行一条数据即n+1条)——SERIALIZABLE事务隔离级别(最高隔离级别)可避免

**InnoDB可重复读隔离级别下如何避免幻读** (MySQL的InnoDB的特性)

1. 表象：快照读(非阻塞读) --伪MVCC
2. 内在：next-key(行锁+gap锁)  **(Gap锁RR级别及以上才有，代价较大，尽量避免)**

**Gap锁会用在非唯一索引或者不走索引的当前读中**

**当前读(获取数据的最新版本)：**`select... lock in share mode, select... for update`、`update, delete, insert`

**快照读(事务隔离级别不能为SERIALIZABLE。 第一次运行快照读时会保存快照)：** 不加锁的非阻塞读，`select`

**对主键索引或者唯一索引会用Gap锁吗**

1. 如果where条件全部命中，则不会用Gap锁，只会加记录锁( 行锁)
2. 如果where条件部分命中或者全不命中，则加Gap锁

---

### 关于SQL语法


**GROUP BY**

1. 满足“SELECT子句中的列名必须为分组列或列函数”
2. 列函数对于group by子句定义的每个组各返回一个结果

**(上述条件针对同一张表才成立)**

ex: 查询所有同学的学号、选课数、总成绩

`select student_id,count(course_id),sum(score) from score `

`group by student_id`;  

**HAVING**

1. 通常与GROUP BY子句一起使用
2. WHERE过滤行，HAVING过滤组
3. 出现在同一SQL的顺序：WHERE > GROUP BY > HAVING

ex: 查询平均成绩大于60分的同学的学号和平均成绩

`select student_id,avg(score)from score`

`group by student_id`

`having avg(score)>60;`

**统计相关: COUNT, SUM, MAX, MIN, AVG**

---
