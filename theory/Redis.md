# Redis

**数据类型丰富、支持数据磁盘持久化存储、支持主从、支持分片**

1. 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高
2. 数据结构简单，对数据操作也简单
3. 采用单线程，单线程也能处理高并发请求，想多核也可启动多实例
4. 使用多路I/O复用模型，非阻塞IO

- #### 多路I/O复用模型

**FD:** File Descriptor，文件描述符

**Redis采用的I/O多路复用函数：** poll/kqueue/evport/select

1. 因地制宜
2. 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现
3. 以时间复杂度为O(n)的select作为保底
4. 基于react设计模式监听I/O事件

- #### Redis的数据类型

**供用户使用的数据类型**

1. **String：** 最基本的数据类型，二进制安全
2. **Hash：** String元素组成的字典，适合用于存储对象   (类似于HashMap<String, String>)
3. **List：** 列表，按照String元素插入顺序排序 (取元素时遵循先进后出，类似于栈)
4. **Set：** String元素组成的无序集合，通过哈希表实现，不允许重复
5. **Sorted Set (ZSet)：** 通过分数(添加的时候赋予)来为集合中的成员进行从小到大的排序
6. **其他：** 用于计数的HyperLogLog，用于支持存储地理位置信息的Geo

**底层数据类型基础**

1. 简单动态字符串
2. 链表
3. 字典
4. 跳跃表
5. 整数集合
6. 压缩列表
7. 对象

- #### 从海量Key里查询出某一固定前缀的Key

**KEYS pattern：** 查找所有符合给定模式pattern的key

1. KEYS指令一次性返回所有匹配的key
2. 键的数量过大会使服务卡顿

**SCAN cursor [MATCH pattern] [COUNT count]**

1. 基于游标(cursor)的迭代器，需要基于上一次的游标延续之前的迭代过程
2. 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
3. 不保证每次执行都返回某个给定数量的元素，支持模糊查询
4. 所有迭代查询到的结果可能会有重复，总体耗费时间比KEYS长

- #### 通过Redis实现分布式锁

**分布式锁需要解决的问题：** 互斥性、安全性、死锁、容错

**SETNX key value(执行独占资源逻辑)：** 如果key不在，则创建并赋值

1. 时间复杂度：O(1)
2. 返回值：设置成功返回1，失败返回0

**如何解决SETNX长期有效的问题：**

**EXPIRE key seconds**

1. 设置key的生存时间，当key过期时(生存时间为0)，会被自动删除
2. 缺点：原子性得不到满足

**SET key value [EX seconds] [PX milliseconds] [NX|XX]**

1. EX second：设置键的过期时间为second秒
2. PX millisecond：设置键的过期时间为millisecond毫秒   **（1,2 二选一即可）**
3. NX：只在键不存在时，才对键进行操作
4. XX：只在键已经存在时，才对键进行设置操作   **（3,4 二选一即可）**
5. SET操作成功时返回OK否则返回nil

**大量的key同时过期的注意事项**

1. **集中过期：** 由于清除大量的key很耗时，会出现短暂的卡顿现象

2. **解决方案：** 在设置key的过期时间的时候，给每个key加上随机值

- #### 如何使用Redis做异步队列

**使用List作为队列，RPUSH生产消息，LPOP消费消息**  (即类似数据结构中的队列)

**缺点：** 没有等待，队列里有值就直接消费

**弥补：** 可以通过在应用层引入Sleep机制取调用LPOP重试



**BLPOP key [key...] timeout：** 阻塞直到队列有消息或者超时

**缺点：** 只能供一个消费者消费



**pub/sub：** 主题订阅者模式（类似简单版的kafka消息队列机制）

1. 发送者(pub)发送消息，订阅者(sub)接收消息
2. 订阅者可以订阅任何数量的频道
3. **缺点：** 消息的发布是无状态的，无法保证可达

- #### Redis如何做持久化：RDB-AOF混合持久化

**（BGSAVE做镜像全量持久化，AOF做增量持久化）**



**RDB(快照)持久化：** 保存某个时间点的全量数据快照

**缺点**

1. 内存数据的全量同步，数据量大会由于I/O而严重影响性能
2. 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据

**指令**

1. SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕
2. **BGSAVE：** Fork出一个子进程来创建RDB文件，不阻塞服务器进程

**（系统调用fork()：创建进程，实现了Copy-on-Write）**

**自动化触发RDB持久化的方式**

1. 根据redis.conf配置里的SAVE m(秒) n(提交次数) 定时触发(用的是BGSAVE)
2. 主从复制时，主节点自动触发
3. 执行Debug Reload
4. 执行Shutdown且没有开启AOF持久化



**AOF(Append-Only-File)持久化：** 保存写状态

1. 记录下除了查询以外的所有变更数据库状态的指令
2. 以append的形式追加保存到AOF文件中(即增量数据)

**日志重写解决AOF文件大小不断增大的问题**

1. 调用fork()，创建一个子进程
2. 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
3. 主进程持续将新的变动同时写到内存和原来的AOF里
4. 主进程获取子进程重写AOF的完成信号后，往新AOF同步增量变动
5. 使用新的AOF文件替换掉旧的AOF文件



**RDB和AOF的优缺点**

**RDB：** 全量数据快照，文件小，恢复快。  无法保存最近一次快照之后的数据

**AOF：** 可读性高，适合保存增量数据，数据不易丢失。  文件体积大，恢复时间长



**Pipeline及主从同步**



**Pipeline**

1. Pipeline和Linux的管道类似
2. Redis基于请求/响应模型，单个请求处理需要一一应答
3. Pipeline批量执行指令，节省多次IO往返时间
4. 有顺序依赖的指令建议分批发送



**Redis的同步机制**

**Master：** 执行写操作   **Slave：** 执行读操作

**全量同步过程：**

1. Slave发送sync命令到Master
2. Master启动一个后台进程，将Redis中的数据快照保存到文件
3. Master将保存数据快照期间接收到的写命令缓存起来
4. Master完成写操作后，将该文件发送给Slave
5. 使用新的RDB文件替换掉旧的RDB文件
6. Master将这期间收集的增量写命令发送给Slave端

**增量同步过程：**

1. Master接收到用户操作指令，判断是否需要传播到Slave
2. 将操作记录追加到AOF文件
3. 将操作传播到其他Slave：1)对齐主从库  2)往响应缓存写入指令
4. 将缓存中的数据发送给Slave



- #### Redis Sentinel（哨兵）：解决主从同步Master宕机后的主从切换问题

1. **监控：** 检查主从服务器是否运作正常
2. **提醒：** 通过API向管理员或者其他应用程序发送故障通知
3. **自动故障迁移：** 主从切换（Master失效后选择一个Slave升级为Master）

**流言协议Gossip：** 在杂乱无章中寻求一致

1. 每个节点都随机地与对方通信，最终所有节点的状态达成一致
2. 种子节点定期随机向其他节点发送节点列表以及需要传播的消息
3. 不保证信息一定会传递给所有节点，但是最终会趋于一致(理论上)



- #### Redis集群

**如何从海量数据里快速找出所需**

**分片：** 按照某种规则划分数据，分散存储在多个节点(节点之间使用Gossio协议传播信息)

常规的按照哈希划分无法实现节点的动态增减

**一致性哈希算法：** 具有较好的容错性和扩展性

1. 对2^32^取模，将哈希值空间组织成虚拟的圆环（即范围固定为0～2^32^ - 1）
2. 将数据key使用相同的函数Hash计算出哈希值并存储在逆时针距离最近的节点

**可能出现的问题：** Hash环的数据倾斜（即节点分配不均匀，导致不同节点存储的数据大小相差过大）

**（Redis引入了虚拟节点解决数据倾斜问题）**

---



