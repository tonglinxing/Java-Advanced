## JAVA底层知识：JVM

- #### JVM架构

**（Java虚拟机是基于内存的）**

**Class Loader：** 依据特定格式，加载class文件到内存

**Execution Engine：** 对命令进行解析

**Native Interface：** 融合不同开发语言的原生库为Java所用

**Runtime Data Area：** JVM内存空间结构模型



**类从编译到执行的过程**

1. 编译器将?.java源文件编译为?.class字节码文件
2. ClassLoader将字节码转换为JVM中的Class<?>对象
3. JVM利用Class<?>对象实例化为?对象

**ClassLoader种类**（1是2的parent，以此类推）

1. BootStrapClassLoader：C++编写，加载核心库java.*
2. ExtClassLoader：Java编写，加载扩展库javax.*
3. AppClassLoader：Java编写，加载程序所在目录
4. 自定义ClassLoader：Java编写，定制化加载

**ClassLoader的双亲委派机制**（目的：避免多份同样字节码的加载）

1. 自底向上检查类是否已经加载（4-1）
2. 自顶向下尝试加载类（1-4）



**类的装载过程**

1. 加载：通过ClassLoader加载文件字节码，生成Class对象

2. 链接：1）校验：检查加载的class的正确性和安全性

   ​		    2）准备：为类变量分配存储空间并设置类变量初始值（此处初始值指的是默认值而非实际赋的值）

   ​			3）解析：JVM将常量池内的符号引用转换为直接引用（此步骤可选）

**类的加载方式**

1. 隐式加载：new
2. 显式加载：loadClass，forName等

**loadClass和forName的区别**

1. ClassLoader.loadClass得到的class是还没有链接的
2. Class.forName得到的class是已经初始化完成的

---



- #### JVM内存模型

-  ##### 线程独占部分

**程序计数器**

1. 当前线程所执行的字节码行号指示器（逻辑）
2. 改变计数器的值来选取下一条需要执行的字节码指令
3. 和线程是一对一的关系，即“线程私有”
4. 对Java方法计数，如果是Native方法则计数器值为Undefined
5. 不会发生内存泄漏

**JVM栈（Stack）**

（递归过深，栈帧数超出虚拟栈深度就会产生StackOverflowError异常）

（虚拟机栈过多会引发OutOfMemoryError异常）

1. Java方法执行的内存模型
2. 包含多个栈帧（栈帧存储局部变量表、操作栈、动态链接、返回地址等）

**本地方法栈：** 与虚拟机栈相似，主要作用于标注了native的方法

**局部变量和操作数栈**

1. 局部变量表：包含方法执行过程中的所有变量
2. 操作数栈：入栈、出栈、复制、交换、产生消费变量



- ##### 线程共享部分

**元空间(MetaSpace)**

**元空间(MetaSpace)与永久代(PermGen)的区别：** 元空间使用本地内存，而永久代使用的是jvm的内存

**MetaSpace相比PerGem的优势**

1. 字符串常量池存在永久代中，容易出现性能问题和内存溢出
2. 类和方法的信息大小难以确定，给永久代的大小指定带来困难
3. 永久代会为GC带来不必要的复杂性
4. 方便HotSpot与其他JVM如 Jrockit 的集成



**Java堆(Heap)**

1. 对象实例的分配区域
2. GC管理的主要区域（故有时Heap会被称为GC堆）



- **面试常见问题**

**JVM三大性能调优参数-Xms -Xmx -Xss的含义**

1. Xms：Heap的初始值
2. Xmx：Heap能达到的最大值
3. Xss：规定了每个线程虚拟机栈（堆栈）的大小

**JVM内存模型中堆和栈的区别----内存分配策略**

1. 静态存储：编译时确定每个数据目标在运行时的存储空间需求
2. 栈式存储：数据区需求在编译时未知，运行时模块入口前确定
3. 堆式存储：编译时或运行时模块入口都无法确定，动态分配

**JVM内存模型中堆和栈**

**联系：** 引用对象、数组时，栈里定义变量保存堆中目标的首地址

**区别**

1. 管理方式：栈自动释放，堆需要GC
2. 空间大小：栈比堆小
3. 碎片相关：栈产生的碎片远小于堆
4. 分配方式：栈支持静态和动态分配，而堆仅支持动态分配
5. 效率：栈的效率比堆高

---



- #### Java垃圾回收机制（GC）



- **垃圾回收：标记算法**

**对象被判定为垃圾的标准：** 没有被其他对象引用

**判定对象是是否为垃圾的算法：** 引用计数算法、**可达性分析算法**

**引用计数算法**

1. 通过判断对象的引用数量来决定对象是否可以被回收
2. 每个对象实例都有一个引用计数器，被引用则+1，完成则-1
3. 任何引用计数为0的对象实例都可以被当作垃圾回收

优点：执行效率高，程序执行受影响较小

缺点：无法检测出循环引用的情况，导致内存泄漏



**可达性分析算法**（GC采纳的方式）

通过判断对象的引用链是否可达来决定对象是否可以被回收

**可以作为GC Root的对象**

1. 虚拟机栈中引用的对象（栈帧中的本地变量表）
2. 方法区中的常量引用对象
3. 方法区中的类静态属性引用的对象
4. 本地方法栈中JNI(Native方法)的引用对象
5. 活跃线程的引用对象



- **垃圾回收：回收算法**

**标记-清除算法（Mark and Sweep）**

1. 标记：从根集合进行扫描，对存活的对象进行标记
2. 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存

缺点：产生大量空间碎片

**复制算法（Copying）**

1. 将可用内存按容量分为对象面和空闲面
2. 对象在对象面上创建
3. 存活的对象被从对象面复制到空闲面
4. 将对象面所有对象内存清除

优点：解决了碎片化问题、顺序分配内存，简单高效、适用于对象存活率低（年轻代）的场景

缺点：成本较高，不适用于对象存活率高（老年代）的场景

**标记-整理算法（Compacting）**

1. 标记：从根集合进行扫描，对存活的对象进行标记
2. 清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收

优点：避免内存的不连续、不用设置两块内存互换、适用于存活率高的场景

**分代收集算法（Generational Collector）**（目前的主流算法）

1. 垃圾算法的组合使用
2. 按照对象声明周期的不同划分区域以采用不同的垃圾回收算法

**GC的分类**

1. Minor GC：针对年轻代，采用复制算法
2. Full GC：针对老年代，采用标记-清理算法或标记-整理算法

**年轻代：** 尽可能快速地收集生命周期短的对象

1. Eden区 ：对象生成区域
2. 两个Survivor区：From与To

**对象如何晋升到老年代**

1. 经历一定Minor次数后依然存活的对象（默认15次）
2. Survivor区中存放不下的对象
3. 新生成的大对象

**老年代：** 存放生命周期较长的对象

1. Full GC 和 Major GC
2. Full GC 比 Minor GC 慢，但执行频率低

**触发Full GC的条件**

1. 老年代空间不足
2. 永久代空间不足（针对jdk7及以前的版本，jdk8后已经取消永久代）
3. CMS GC时出现promotion failed, concurrent mode failure
4. Minor GC晋升到老年代的平均大小大于老年代的剩余空间
5. 程序直接调用System.gc()
6. 使用RMI来进行RPC或管理的JDK应用，每小时执行一次Full GC



**Stop-the-World**

1. JVM由于要执行GC而停止了应用程序的执行
2. 任何一种GC算法中都会发生
3. 多数GC优化通过减少Stop-the-World发生的时间来提高程序性能

**SafePoint**

1. 可达性分析过程中对象引用关系不会发生变化的点
2. 产生SafePoint的地方：方法调用、循环跳转、异常跳转等
3. 安全点数量需要适中



- **常见的垃圾收集器**

**JVM的运行模式：** Server, Client

**吞吐量** = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)

**年轻代常见的垃圾收集器**

Serial收集器(-XX:+UseSerialGC, 复制算法)：

1. 单线程收集，进行垃圾收集时，必须暂停所有工作线程
2. 简单高效，Client模式下默认的年轻代收集器

ParNew收集器(-XX:+UseParNewGC, 复制算法)：

1. 多线程收集，其余的行为、特点和Serial收集器一样
2. 单核执行效率不如Serial，在多核下执行才有优势

Parallel Scavenge收集器(-XX:+UseParallelGC, 复制算法)

1. 比起关注用户线程停顿时间，更关注系统的吞吐量
2. 在多核下执行才有优势，Server模式下默认的年轻代收集器



**老年代常见的垃圾收集器**

Serial Old收集器(-XX:+UseSerialOldGC, 标记-整理算法)

1. 单线程收集，进行垃圾收集时，必须暂停所有工作线程
2. 简单高效，Client模式下默认的老年代收集器

Parallel Old收集器(-XX:+UseParallelOldGC, 标记-整理算法)

1. 多线程，吞吐量优先

**CMS收集器**(-XX:+UseConcMarkSweepGC, 标记-清除算法)

1. 初始标记：stop-the-world
2. 并发标记：并发追溯标记，程序不会停顿
3. 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象
4. 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象
5. 并发清理：清理垃圾对象，程序不会停顿
6. 并发重置：重置CMS收集器的数据结构



**特别一点的收集器：** 跨越新生代和老年代

G1(Garbage First)收集器(-XX:+UseG1GC, 复制+标记-整理算法)

特点：并行和并发、分代收集、空间整合、可预测的停顿

1. 将整个Java堆内存划分成多个大小相等的Region
2. 年轻代和老年代不再物理隔离



- **GC相关的面试题**



**Object的finalize()方法的作用是否与C++的析构函数作用相同**

与C++的析构函数不同，析构函数调用时间点确定而finalize()不确定性较大

**作用**

1. 将未被引用的对象放置于F-Queue队列
2. 方法执行随时可能会被终止
3. 给予对象最后一次重生的机会



**Java中的强引用、软引用、弱引用、虚引用有什么作用**

强引用 > 软引用 > 弱引用 > 虚引用

**强引用**

1. 最普遍的引用：Object obj = new Object()
2. 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
3. 若不再使用该对象，需要通过将对象设置为null来弱化引用，使其被回收

**软引用**

1. 对象处在有用但非必须的状态
2. 只有当内存空间不足时，GC才回收该引用的对象的内存
3. 可以用来实现高速缓存

**弱引用**

1. 非必须的对象，比软引用更弱一些
2. GC时会被回收
3. 被回收的概率不大，因为GC线程优先级比较低
4. 适用于引用偶尔被使用且不影响垃圾收集的对象

**虚引用**

1. 不会决定对象的生命周期
2. 任何时候都可能被垃圾收集器回收
3. 跟踪对象被垃圾收集器回收的活动，起哨兵作用
4. 必须和引用队列ReferenceQueue联合使用

**引用队列(ReferenceQueue)**

1. 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达（即本身只含有一个head节点，其具体逻辑按照next指针来表明）
2. 存储关联的且被GC的软引用，弱引用以及虚引用

```java
String str = new String("abc");//强引用
SoftReference<String> softRef = new SoftReference<String>(str);//软引用
WeakReference<String> weakRef = new WeakReference<String>(str);//弱引用

ReferenceQueue queue = new Reference();
PhantomReference ref = new PhantomReference(str, queue);//虚引用
```

---

















