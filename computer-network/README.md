
# 计算机网络

### 关于TCP 

**ACK：确认信号标志**
**SYN：同步序号, 用于建立连接过程**

- #### TCP三次握手

**在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接**

**第一次握手：** 建立连接时，客户端发送SYN包（seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认；

**第二次握手：** 服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送发一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

**第三次握手：** 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

**为什么需要三次握手才能建立起连接：**

为了初始化Sequence Number（SYN）的初始值

保证双方互相得知 对方收发能力正常的最低值

**首次握手的隐患---SYN超时：**
**1. 问题起因分析**

Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认

Server不断重试直至超时，Linux默认等待63秒才断开连接

**2. 针对SYN Flood（一种针对SYN超时的网络攻击）的防护措施**

SYN队列满后，通过tcp--syncookies参数回发SYN Cookie

- #### TCP四次挥手

**挥手是为了终止连接，TCP采用四次挥手来释放连接**

**第一次挥手：** Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；

**第二次挥手：** Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态；

**第三次挥手：** Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；

**第四次挥手：** Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server收到后进入CLOSED状态，完成四次挥手。Client在等待2MSL时间后也进入CLOSED状态。
**为什么Client会有TIME_WAIT状态：**

1. 确保有足够的时间让对方收到ACK包
2. 避免新旧连接混淆（因为有些路由器可能会缓存IP数据包）

**为什么需要四次挥手才能断开连接：**

因为全双工，发送方和接收方都需要FIN报文和ACK报文（即客户端（主动）和服务器（被动）各自需要两次挥手）

**服务器出现大量CLOSE_WAIT状态(超过四位数的数量)的原因：**

**对方关闭socket连接，我方忙于读或写，没有及时关闭连接**

1. 检查代码，特别是释放资源的代码
2. 检查配置，特别是处理请求的线程配置

- #### TCP和UDP的区别

**1. 面向连接 vs 无连接**

**2. 可靠性**

**3. 有序性**

**4. 速度：** TCP速度较慢

**5. 量级：** TCP属于重量级，体现在头字节大小。（TCP 20 UDP 8）

- #### TCP的滑动窗口

**RTT:**  发送一个数据包到收到对应的ACK所花费的时间

**RTO:**  重传时间间隔（一段时间内未收到ACK就重传）, 通过RTT计算出来

**（可靠性是基于确认重传机制基础上的）**

**TCP使用滑动窗口做流量控制和乱序重排**

1. 保证TCP的可靠性
2. 保证TCP的流量控制特性

---

### 关于HTTP(超文本传输协议)

**支持客户/服务器模式、简单快速（GET/PUT/POST...）、灵活（允许传输任意类型对象）、无连接、无状态**

**请求/响应的步骤：**

1. 客户端连接到Web服务器（建立TCP套接字连接）
2. 发送HTTP请求
3. 服务器接收请求并返回HTTP响应
4. 释放TCP连接
5. 客户端浏览器解析HTML内容


**在浏览器地址栏键入URL，按下回车之后经历的流程：**

1. DNS解析（浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、域名服务器缓存、顶级域名服务器缓存）
2. TCP连接（三次握手）
3. 浏览器发送HTTP请求到服务器
4. 服务器处理请求并返回HTTP报文 
5. 浏览器解析渲染页面
6. 连接结束（四次挥手）

**HTTP状态码**

**（五种可能的取值）**

**1xx：** 指示信息--表示请求已接收，继续处理 

**2xx：** 成功--表示请求已被成功接收、理解、接受

ex：200 OK 正常返回信息

**3xx：** 重定向--要完成请求必须进行更进一步的操作（与跳转相关）

**4xx：** 客户端错误--请求有语法错误或请求无法实现

ex：404 Not Found 请求资源不存在（输入了错误的URL）

**5xx：** 服务器端错误--服务器未能实现合法的请求

**GET请求和POST请求的区别：**

**（从三个层面解答）**

**Http报文层面：** GET将请求信息放在URL，POST放在报文体中

**数据库层面：** GET符合幂等性(对数据库的一次操作或多次操作获得的结果一致)和安全性(操作不改变数据库数据)，POST不符合

**其他层面：** GET可以被缓存、被存储，而POST不行

**Cookie和Session的区别：**

**Cookie**


1. 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端
2. 客户端再次请求的时候，会把Cookie回发（存放在请求头中）
3. 服务器接收到后，会解析Cookie生成与客户端相对应的内容

**Session**

1. 服务器端的机制，在服务器上保存的信息
2. 解析客户端请求并操作session id（对应客户端的某个请求），按需保存状态信息

**区别：**

1. Cookie数据存放在客户的浏览器上，Session数据存放在服务器上
2. Session相对于Cookie更安全
3. 若考虑减轻服务器负担，可以将一些不重要的信息保存在Cookie上

**HTTP和HTTPS(超文本传输安全协议)的区别：**

**SSL(Security Socket Layer安全套接层)** 为网络通信提供安全及数据完整性的一种安全协议

1. 为网络通信提供安全及数据完整性的一种安全协议
2. 是操作系统对外的API，SSL3.0后更名为TLS
3. 采用身份验证和数据加密保证网络通信的安全和数据的完整性

**加密的方式**

**对称加密：** 加密和解密都使用同一套密钥

**非对称加密：** 加密和解密使用不相同的密钥（区块链）

**哈希算法：** 将任意长度的信息转换为固定长度的值，算法不可逆（常见的有MD5算法）

**数字签名：** 证明某个消息或者文件是某人发出/认同的

**HTTPS数据传输过程**

1. 浏览器将支持的加密算法信息发送给服务器
2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
3. 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器
4. 服务器使用私钥解密信息，验证哈希（数字签名），加密响应消息回发浏览器
5. 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据

**区别：**

1. HTTPS需要到CA申请证书（要钱），HTTP不需要
2. HTTPS密文传输，HTTP明文传输
3. 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口
4. HTTPS = HTTP + 加密 + 认证 + 完整性保护，较HTTP安全

**HTTPS一定安全吗：** （未必）

1. 浏览器默认填充http://, 请求需要进行跳转，有被劫持的风险
2. 可以使用HSTS(HTTP Strict Transport Security)优化

---

### 关于Socket(套接字编程)

**Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口**

- #### Socket通信流程

**Server：** 创建socket - 绑定socket和端口号 - 监听该端口号 - 接收来自客户端的连接请求 - 从socket中读取字符 - 关闭socket

**Client：** 创建socket - 连接指定计算机的端口 - 向socket中写入信息 - 关闭socket

---


